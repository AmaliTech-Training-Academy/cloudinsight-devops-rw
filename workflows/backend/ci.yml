name: Backend CI with Docker Multi-Platform Build

on:
  # Trigger on all branches for push events (commits)
  push:
    branches: ["*"]

  # Trigger on pull requests to any branch
  pull_request:
    branches: ["*"]

  # Trigger on merge events (when PR is merged)
  merge_group:

jobs:
  backend-ci:
    name: Backend CI Pipeline with Docker Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Decrypt environment variables
        id: decrypt-env
        run: |
          echo "üîç Checking for encrypted environment files..."

          # Setup cleanup trap for any exit (success or failure)
          cleanup() {
            echo "üßπ Performing security cleanup..."
            rm -f ./team-private-key.pem ./temp-aes-key ./.env
            echo "‚úÖ Security cleanup completed"
          }
          trap cleanup EXIT

          # Find encrypted files in repository root
          ENCRYPTED_DATA=$(find . -maxdepth 1 -name "encrypted-env-vars.enc" -type f | head -1)
          ENCRYPTED_KEY=$(find . -maxdepth 1 -name "encrypted-aes-key.enc" -type f | head -1)
          METADATA=$(find . -maxdepth 1 -name "encrypted-env-vars.meta" -type f | head -1)

          if [[ -z "$ENCRYPTED_DATA" || -z "$ENCRYPTED_KEY" ]]; then
            echo "‚ÑπÔ∏è No encrypted environment files found - continuing without decryption"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Found encrypted files:"
          echo "  Data: $ENCRYPTED_DATA"
          echo "  Key: $ENCRYPTED_KEY"
          if [[ -n "$METADATA" ]]; then
            echo "  Metadata: $METADATA"
          fi
          echo "has_encrypted_env=true" >> $GITHUB_OUTPUT

          # Create private key from secret
          echo "üîë Setting up private key for decryption..."
          echo "${{ secrets.TEAM_PRIVATE_KEY }}" > ./team-private-key.pem
          chmod 600 ./team-private-key.pem

          # Verify private key
          if ! openssl rsa -in ./team-private-key.pem -check -noout; then
            echo "‚ùå Invalid private key in TEAM_PRIVATE_KEY secret"
            exit 1
          fi
          echo "‚úÖ Private key validated"

          # Show metadata if available (without sensitive content)
          if [[ -n "$METADATA" && -f "$METADATA" ]]; then
            echo "üìã Encryption Metadata:"
            echo "======================="
            cat "$METADATA"
            echo "======================="
          fi

          # Decrypt AES key
          echo "üîì Decrypting AES key..."
          if ! openssl rsautl -decrypt \
            -inkey ./team-private-key.pem \
            -in "$ENCRYPTED_KEY" \
            -out ./temp-aes-key; then
            echo "‚ùå Failed to decrypt AES key"
            exit 1
          fi

          # Read AES key
          AES_KEY=$(cat ./temp-aes-key)

          # Decrypt data (try GCM first, then CBC)
          echo "üîì Decrypting environment data..."
          if openssl enc -aes-256-gcm -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-GCM"
          elif openssl enc -aes-256-cbc -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-CBC"
          else
            echo "‚ùå Decryption failed with both AES-GCM and AES-CBC"
            exit 1
          fi

          # Verify decrypted content (without exposing content)
          if [[ -f "./.env" ]]; then
            LINES=$(wc -l < "./.env")
            SIZE=$(stat -c%s "./.env")
            echo "‚úÖ Decryption completed successfully!"
            echo "üìã Decrypted .env file: $LINES lines, $SIZE bytes"
            echo "‚ö†Ô∏è Environment variables are available for build process only"
            
            # Ensure .env is not tracked by git
            echo ".env" >> .gitignore
            git add .gitignore 2>/dev/null || true
          else
            echo "‚ùå Decrypted .env file not found"
            exit 1
          fi

      - name: Check for Java source files
        id: check-java
        run: |
          # Check if there are any Java files in the repository
          JAVA_FILES=$(find . -name "*.java" -type f | head -5)

          if [ -z "$JAVA_FILES" ]; then
            echo "‚ö†Ô∏è No Java source files found in repository"
            echo "‚úÖ Skipping Java build steps - repository not yet initialized with Java code"
            echo "has_java=false" >> $GITHUB_OUTPUT
          else
            echo "‚òï Java source files found:"
            echo "$JAVA_FILES"
            echo "‚úÖ Proceeding with Java build pipeline"
            echo "has_java=true" >> $GITHUB_OUTPUT
          fi

      - name: Early success for non-Java repositories
        if: steps.check-java.outputs.has_java == 'false'
        run: |
          echo "üéâ CI passed successfully!"
          echo "‚úÖ Repository validated (no Java code found - this is expected for new repositories)"
          echo "‚úÖ Ready for Java development"
          exit 0

      - name: Set up Docker Buildx
        if: steps.check-java.outputs.has_java == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Check for pom.xml
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          if [ ! -f "pom.xml" ]; then
            echo "‚ùå pom.xml not found - Maven project required"
            exit 1
          fi
          echo "‚úÖ Maven pom.xml found"

      - name: Validate Maven project structure
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check for src directory structure
          if [ ! -d "src/main/java" ]; then
            echo "‚ùå src/main/java directory not found"
            exit 1
          fi
          echo "‚úÖ Maven project structure validated"

      - name: Check for Spring Boot application
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Look for Spring Boot indicators
          if grep -q "spring-boot" pom.xml; then
            echo "‚úÖ Spring Boot project detected"
          else
            echo "‚ö†Ô∏è Spring Boot dependencies not found in pom.xml"
          fi

      - name: Build multi-platform Docker image
        if: steps.check-java.outputs.has_java == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: false
          tags: |
            cloudinsight-backend:latest
            cloudinsight-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDPLATFORM=linux/amd64
            TARGETPLATFORM=linux/amd64

      - name: Test Docker image
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          echo "üß™ Testing Docker image functionality..."

          # Load the built image
          docker buildx build --load --platform linux/amd64 -t cloudinsight-backend:test .

          # Run the container in detached mode
          CONTAINER_ID=$(docker run -d -p 8080:8080 cloudinsight-backend:test)

          # Wait for container to start (Spring Boot needs more time)
          echo "‚è≥ Waiting for Spring Boot application to start..."
          sleep 30

          # Check if container is running
          if docker ps | grep $CONTAINER_ID; then
            echo "‚úÖ Container started successfully"
            
            # Test if the app responds (Spring Boot actuator health endpoint)
            if command -v curl &> /dev/null; then
              # Try health endpoint first
              if curl -f http://localhost:8080/actuator/health &> /dev/null; then
                echo "‚úÖ Spring Boot actuator health endpoint responds"
              elif curl -f http://localhost:8080/ &> /dev/null; then
                echo "‚úÖ Application root endpoint responds"
              else
                echo "‚ö†Ô∏è Application not responding (this might be normal for some configurations)"
                echo "üìã Container logs:"
                docker logs $CONTAINER_ID | tail -20
              fi
            fi
          else
            echo "‚ùå Container failed to start"
            echo "üìã Container logs:"
            docker logs $CONTAINER_ID
            exit 1
          fi

          # Cleanup
          docker stop $CONTAINER_ID && docker rm $CONTAINER_ID

      - name: Validate application properties
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check for application configuration
          if [ -f "src/main/resources/application.properties" ] || [ -f "src/main/resources/application.yml" ] || [ -f "src/main/resources/application.yaml" ]; then
            echo "‚úÖ Application configuration found"
          else
            echo "‚ö†Ô∏è No application.properties/yml found (using Spring Boot defaults)"
          fi

      - name: Check for tests
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check if there are any test files
          TEST_FILES=$(find src/test -name "*.java" -type f 2>/dev/null | head -5)

          if [ -z "$TEST_FILES" ]; then
            echo "‚ö†Ô∏è No test files found in src/test"
          else
            echo "‚úÖ Test files found:"
            echo "$TEST_FILES"
          fi

      - name: Final validation
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          echo "üéâ All CI checks passed successfully!"
          echo "‚úÖ Java project structure validated"
          echo "‚úÖ Multi-platform Docker image built"
          echo "‚úÖ Container functionality tested"
          echo "‚úÖ Ready for deployment on AMD64 and ARM64 architectures"
