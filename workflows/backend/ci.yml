---
name: Backend CI with Docker Multi-Platform Build and Deployment

permissions:
  contents: write
  checks: write
  actions: read
  id-token: write

concurrency:
  group: backend-ci-${{ github.ref }}
  cancel-in-progress: true

on:
  # Trigger on all branches for push events (commits)
  push:
    branches: ["*"]

  # Trigger on pull requests to any branch
  pull_request:
    branches: ["*"]

  # Trigger on merge events (when PR is merged)
  merge_group:

jobs:
  backend-ci:
    name: Backend CI Pipeline with Docker Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Java source files
        id: check-java
        run: |
          # Check if there are any Java files in the repository
          JAVA_FILES=$(find . -name "*.java" -type f | head -5)

          if [ -z "$JAVA_FILES" ]; then
            echo "‚ö†Ô∏è No Java source files found in repository"
            echo "‚úÖ Skipping Java build steps - repository not yet initialized with Java code"
            echo "has_java=false" >> $GITHUB_OUTPUT
          else
            echo "‚òï Java source files found:"
            echo "$JAVA_FILES"
            echo "‚úÖ Proceeding with Java build pipeline"
            echo "has_java=true" >> $GITHUB_OUTPUT
          fi

      - name: Early success for non-Java repositories
        if: steps.check-java.outputs.has_java == 'false'
        run: |
          echo "üéâ CI passed successfully!"
          echo "‚úÖ Repository validated (no Java code found - this is expected for new repositories)"
          echo "‚úÖ Ready for Java development"
          exit 0

      - name: Set up JDK 21
        if: steps.check-java.outputs.has_java == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "maven"

      - name: Run unit tests with JaCoCo (no packaging)
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          set -e
          # Run tests + generate JaCoCo report without modifying pom.xml by invoking plugin directly
          mvn -B -q org.jacoco:jacoco-maven-plugin:prepare-agent test org.jacoco:jacoco-maven-plugin:report
          # Ensure report exists
          if [ ! -f target/site/jacoco/jacoco.xml ]; then echo "JaCoCo report missing"; exit 1; fi

      - name: Upload backend test artifacts
        if: ${{ always() && steps.check-java.outputs.has_java == 'true' }}
        run: |
          set -e
          mkdir -p ci-artifacts/backend
          if ls target/surefire-reports/*.xml >/dev/null 2>&1; then cp target/surefire-reports/*.xml ci-artifacts/backend/; fi
          [ -f target/site/jacoco/jacoco.xml ] && cp target/site/jacoco/jacoco.xml ci-artifacts/backend/
          if [ -d target/site/jacoco ]; then tar -czf ci-artifacts/backend/jacoco-html.tar.gz -C target/site jacoco; fi

      - name: Store backend artifacts
        if: ${{ always() && steps.check-java.outputs.has_java == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-and-coverage
          path: ci-artifacts/backend
          if-no-files-found: ignore
          retention-days: 7

      - name: Annotate backend test results
        if: ${{ always() && steps.check-java.outputs.has_java == 'true' }}
        uses: dorny/test-reporter@v1
        with:
          name: Backend Tests
          path: target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: false

      - name: Backend coverage summary
        if: ${{ always() && steps.check-java.outputs.has_java == 'true' }}
        run: |
          echo "## Backend Test Summary" >> $GITHUB_STEP_SUMMARY
          if ls target/surefire-reports/*.xml >/dev/null 2>&1; then
            TOTAL=$(grep -h '<testsuite' target/surefire-reports/*.xml | awk -F'tests="' '{print $2}' | cut -d '"' -f1 | awk '{s+=$1} END {print s+0}')
            FAIL=$(grep -h '<testsuite' target/surefire-reports/*.xml | awk -F'failures="' '{print $2}' | cut -d '"' -f1 | awk '{s+=$1} END {print s+0}')
            echo "Tests: $TOTAL, Failures: $FAIL" >> $GITHUB_STEP_SUMMARY
          else
            echo "No surefire XML reports" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -f target/site/jacoco/jacoco.xml ]; then
            LINE_COVERED=$(grep '<counter type="LINE"' target/site/jacoco/jacoco.xml | head -1 | sed -E 's/.*covered="([0-9]+)".*$/\1/')
            LINE_MISSED=$(grep '<counter type="LINE"' target/site/jacoco/jacoco.xml | head -1 | sed -E 's/.*missed="([0-9]+)".*$/\1/')
            TOTAL=$((LINE_COVERED + LINE_MISSED))
            if [ "$TOTAL" -gt 0 ]; then PCT=$(awk -v c=$LINE_COVERED -v t=$TOTAL 'BEGIN{printf("%.2f", (c/t)*100)}'); else PCT=0; fi
            echo "Coverage (lines): $PCT% ($LINE_COVERED/$TOTAL)" >> $GITHUB_STEP_SUMMARY
          else
            echo "No jacoco.xml" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Decrypt environment variables (post-tests, optional)
        if: steps.check-java.outputs.has_java == 'true'
        id: decrypt-env
        run: |
          echo "üîç Checking for encrypted environment files (after tests)..."
          cleanup() { rm -f ./team-private-key.pem ./temp-aes-key; }
          trap cleanup EXIT
          ENCRYPTED_DATA=$(find . -maxdepth 1 -name "encrypted-env-vars.enc" -type f | head -1)
          ENCRYPTED_KEY=$(find . -maxdepth 1 -name "encrypted-aes-key.enc" -type f | head -1)
          if [[ -z "$ENCRYPTED_DATA" || -z "$ENCRYPTED_KEY" ]]; then
            echo "‚ÑπÔ∏è No encrypted env files found - skipping deployment"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "${{ secrets.TEAM_PRIVATE_KEY }}" > ./team-private-key.pem; chmod 600 ./team-private-key.pem
          openssl rsautl -decrypt -inkey ./team-private-key.pem -in "$ENCRYPTED_KEY" -out ./temp-aes-key
          AES_KEY=$(cat ./temp-aes-key)
          if ! openssl enc -aes-256-gcm -d -in "$ENCRYPTED_DATA" -out "./.env" -pass "pass:$AES_KEY" 2>/dev/null; then
            openssl enc -aes-256-cbc -d -in "$ENCRYPTED_DATA" -out "./.env" -pass "pass:$AES_KEY" 2>/dev/null || { echo "‚ùå Decrypt failed"; exit 1; }
          fi
          if [[ -f ./.env ]]; then
            echo "‚úÖ Environment variables decrypted successfully"
            grep -q '^\.env$' .gitignore 2>/dev/null || echo ".env" >> .gitignore
            git add .gitignore 2>/dev/null || true
            echo "has_encrypted_env=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to create .env file"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Configure AWS credentials
        if: steps.check-java.outputs.has_java == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy environment variables to AWS Secrets Manager
        if: steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üöÄ Deploying environment variables to AWS Secrets Manager..."

          # Verify .env file exists
          if [[ ! -f ./.env ]]; then
            echo "‚ùå .env file not found! This should not happen if decryption succeeded."
            exit 1
          fi

          SECRET_NAME="${{ secrets.AWS_SECRET_NAME_BACKEND }}"
          if [[ -z "$SECRET_NAME" ]]; then
            echo "‚ùå AWS_SECRET_NAME_BACKEND secret not configured"
            exit 1
          fi

          # Remove database secrets from .env before processing
          echo "üö´ Removing database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) from environment variables..."
          sed -i '/^DB_PASSWORD=/d; /^DB_URL=/d; /^DB_USERNAME=/d' .env

          echo "üìä Remaining environment variables after database secret exclusion:"
          grep -c "^[^#].*=" .env || echo "0"

          # Simple function to build JSON from env file
          clean_and_build_json() {
            local env_file="$1"
            local output_file="$2"
            
            # Use a single Python command to build clean JSON
            python3 -c "import json,re; data={}; [data.update({line.split('=',1)[0].strip(): re.sub(r'[\x00-\x1f\x7f]','',line.split('=',1)[1].split('#')[0].strip())}) for line in open('$env_file') if '=' in line and not line.strip().startswith('#') and line.strip()]; json.dump(data, open('$output_file','w'), ensure_ascii=False, separators=(',',':'))"
            
            # Log what was processed
            echo "ÔøΩ Built JSON with $(python3 -c "import json; print(len(json.load(open('$output_file'))))" 2>/dev/null || echo "0") environment variables"
          }

          # Check if secret exists and deploy as key-value pairs (Other type of secret)
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Secret exists, updating with merge strategy..."
            
            # Get existing secret and clean it
            EXISTING_SECRET=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text)
            echo "$EXISTING_SECRET" > /tmp/existing_raw.json
            
            # Create new values JSON using the robust function
            clean_and_build_json ".env" "/tmp/new_vars.json"
            
            # Clean and merge using single-line Python
            python3 -c "import json,re; existing={}; exec('try:\n with open(\"/tmp/existing_raw.json\") as f: content=f.read()\n clean_content=re.sub(r\"[\x00-\x1f\x7f]\",\"\",content)\n existing=json.loads(clean_content)\nexcept: existing={}'); new=json.load(open('/tmp/new_vars.json')); existing.update(new); json.dump(existing,open('/tmp/merged.json','w'),ensure_ascii=False,separators=(',',':'))"
            
            # Update secret with merged values
            aws secretsmanager update-secret \
              --secret-id "$SECRET_NAME" \
              --secret-string "$(cat /tmp/merged.json)"
            
            echo "‚úÖ Secret updated successfully with merge strategy"
            
            # Cleanup
            rm -f /tmp/existing_raw.json /tmp/new_vars.json /tmp/merged.json
          else
            echo "üÜï Creating new secret as 'Other type' with key-value pairs..."
            
            # Create JSON with all key-value pairs using the robust function
            clean_and_build_json ".env" "/tmp/new.json"
            
            # Create new "Other type of secret" with key-value pairs in JSON format
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --description "Backend environment variables for ${{ github.repository }} (Other type - Key/Value pairs)" \
              --secret-string "$(cat /tmp/new.json)"
            
            echo "‚úÖ Secret created successfully as 'Other type' with all key-value pairs"
            
            # Cleanup
            rm -f /tmp/new.json
          fi

          echo "üîê Environment variables deployed to AWS Secrets Manager: $SECRET_NAME"
          echo "üö´ Database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) excluded from deployment"

      - name: Login to Amazon ECR
        if: steps.check-java.outputs.has_java == 'true'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Calculate next semantic version
        if: steps.check-java.outputs.has_java == 'true'
        id: semver
        run: |
          echo "üè∑Ô∏è Calculating next semantic version for branch: ${{ github.ref_name }}"
          BRANCH_NAME="${{ github.ref_name }}"

          # Get the latest tag from the current branch with branch suffix
          LATEST_TAG=$(git tag -l --sort=-version:refname "v*-${BRANCH_NAME}" | head -1 || echo "")

          if [[ -z "$LATEST_TAG" ]]; then
            # If no branch-specific tag, look for any v* tag for this branch's starting point
            LATEST_TAG=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
            # Remove any branch suffix if it exists
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          else
            # Remove the branch suffix to get the version number
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          fi

          echo "Latest tag found: $LATEST_TAG"

          # Extract version numbers
          if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            echo "Found existing version: v${MAJOR}.${MINOR}.${PATCH}"
            # Increment patch version
            PATCH=$((PATCH + 1))
          else
            echo "No semantic version tag found, starting with v0.1.0"
            MAJOR=0
            MINOR=1
            PATCH=0
          fi

          NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"

          echo "Next version: $NEXT_VERSION"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "version_no_v=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        if: steps.check-java.outputs.has_java == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Check for pom.xml
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          if [ ! -f pom.xml ]; then
            echo "‚ùå pom.xml not found - Maven project required"
            exit 1
          fi
          echo "‚úÖ Maven pom.xml found"

      - name: Validate Maven project structure
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check for src directory structure
          if [ ! -d "src/main/java" ]; then
            echo "‚ùå src/main/java directory not found"
            exit 1
          fi
          echo "‚úÖ Maven project structure validated"

      - name: Check for Spring Boot application
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Look for Spring Boot indicators
          if grep -q "spring-boot" pom.xml; then
            echo "‚úÖ Spring Boot project detected"
          else
            echo "‚ö†Ô∏è Spring Boot dependencies not found in pom.xml"
          fi

      - name: Build and push multi-platform Docker image to ECR
        if: steps.check-java.outputs.has_java == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BACKEND }}:${{ steps.semver.outputs.version }}
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BACKEND }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDPLATFORM=linux/amd64
            TARGETPLATFORM=linux/amd64

      - name: Create and push git tag
        if: steps.check-java.outputs.has_java == 'true' && github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/production')
        run: |
          # Extract branch name for tag prefix
          BRANCH_NAME="${{ github.ref_name }}"
          echo "üè∑Ô∏è Creating and pushing git tag for branch: $BRANCH_NAME"
          echo "üìù Version: ${{ steps.semver.outputs.version }}"

          # Configure git with GitHub token
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create branch-specific tag
          TAG_NAME="${{ steps.semver.outputs.version }}-${BRANCH_NAME}"

          # Check if tag already exists
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "‚ö†Ô∏è Tag $TAG_NAME already exists, skipping"
            exit 0
          fi

          # Create annotated tag with branch info
          git tag -a "$TAG_NAME" -m "Backend release ${{ steps.semver.outputs.version }} from branch $BRANCH_NAME"

          # Push tag with authentication
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "$TAG_NAME"

          echo "‚úÖ Tag $TAG_NAME created and pushed successfully"

      - name: Validate application properties
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check for application configuration
          if [ -f "src/main/resources/application.properties" ] || [ -f "src/main/resources/application.yml" ] || [ -f "src/main/resources/application.yaml" ]; then
            echo "‚úÖ Application configuration found"
          else
            echo "‚ö†Ô∏è No application.properties/yml found (using Spring Boot defaults)"
          fi

      - name: Check for tests
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          # Check if there are any test files
          TEST_FILES=$(find src/test -name "*.java" -type f 2>/dev/null | head -5)

          if [ -z "$TEST_FILES" ]; then
            echo "‚ö†Ô∏è No test files found in src/test"
          else
            echo "‚úÖ Test files found:"
            echo "$TEST_FILES"
          fi

      - name: Final validation
        if: steps.check-java.outputs.has_java == 'true'
        run: |
          echo "üéâ All CI checks passed successfully!"
          echo "‚úÖ Java project structure validated"
          echo "‚úÖ Tests executed prior to Docker build"
          echo "‚úÖ Multi-platform Docker image built and pushed to ECR"
          if [[ "${{ steps.decrypt-env.outputs.has_encrypted_env }}" == "true" ]]; then
            echo "‚úÖ Environment variables deployed to AWS Secrets Manager"
          fi
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/development" || "${{ github.ref }}" == "refs/heads/staging" || "${{ github.ref }}" == "refs/heads/production") ]]; then
            echo "‚úÖ Git tag ${{ steps.semver.outputs.version }}-${{ github.ref_name }} created and pushed"
          fi
          if [ -f target/site/jacoco/jacoco.xml ]; then
            LINE_COVERED=$(grep '<counter type="LINE"' target/site/jacoco/jacoco.xml | head -1 | sed -E 's/.*covered="([0-9]+)".*$/\1/')
            LINE_MISSED=$(grep '<counter type="LINE"' target/site/jacoco/jacoco.xml | head -1 | sed -E 's/.*missed="([0-9]+)".*$/\1/')
            TOTAL=$((LINE_COVERED + LINE_MISSED))
            if [ "$TOTAL" -gt 0 ]; then PCT=$(awk -v c=$LINE_COVERED -v t=$TOTAL 'BEGIN{printf("%.2f", (c/t)*100)}'); else PCT=0; fi
            echo "üìä Line coverage: $PCT% ($LINE_COVERED/$TOTAL)"; else echo "üìä Line coverage: n/a"; fi
          echo "üöÄ Backend successfully deployed and ready for use"

      - name: Cleanup sensitive files
        if: always() && steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üßπ Cleaning up sensitive files..."
          rm -f ./.env ./team-private-key.pem ./temp-aes-key
          echo "‚úÖ Cleanup completed"
