name: Frontend CI with Docker Multi-Platform Build

on:
  # Trigger on all branches for push events (commits)
  push:
    branches: ["*"]

  # Trigger on pull requests to any branch
  pull_request:
    branches: ["*"]

  # Trigger on merge events (when PR is merged)
  merge_group:

jobs:
  frontend-ci:
    name: Frontend CI Pipeline with Docker Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Decrypt environment variables
        id: decrypt-env
        run: |
          echo "üîç Checking for encrypted environment files..."

          # Setup cleanup trap for any exit (success or failure)
          cleanup() {
            echo "üßπ Performing security cleanup..."
            rm -f ./team-private-key.pem ./temp-aes-key ./.env ./next-public-build-args.txt
            echo "‚úÖ Security cleanup completed"
          }
          trap cleanup EXIT

          # Find encrypted files in repository root
          ENCRYPTED_DATA=$(find . -maxdepth 1 -name "encrypted-env-vars.enc" -type f | head -1)
          ENCRYPTED_KEY=$(find . -maxdepth 1 -name "encrypted-aes-key.enc" -type f | head -1)
          METADATA=$(find . -maxdepth 1 -name "encrypted-env-vars.meta" -type f | head -1)

          if [[ -z "$ENCRYPTED_DATA" || -z "$ENCRYPTED_KEY" ]]; then
            echo "‚ÑπÔ∏è No encrypted environment files found - continuing without decryption"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Found encrypted files:"
          echo "  Data: $ENCRYPTED_DATA"
          echo "  Key: $ENCRYPTED_KEY"
          if [[ -n "$METADATA" ]]; then
            echo "  Metadata: $METADATA"
          fi
          echo "has_encrypted_env=true" >> $GITHUB_OUTPUT

          # Create private key from secret
          echo "üîë Setting up private key for decryption..."
          echo "${{ secrets.TEAM_PRIVATE_KEY }}" > ./team-private-key.pem
          chmod 600 ./team-private-key.pem

          # Verify private key
          if ! openssl rsa -in ./team-private-key.pem -check -noout; then
            echo "‚ùå Invalid private key in TEAM_PRIVATE_KEY secret"
            exit 1
          fi
          echo "‚úÖ Private key validated"

          # Show metadata if available (without sensitive content)
          if [[ -n "$METADATA" && -f "$METADATA" ]]; then
            echo "üìã Encryption Metadata:"
            echo "======================="
            cat "$METADATA"
            echo "======================="
          fi

          # Decrypt AES key
          echo "üîì Decrypting AES key..."
          if ! openssl rsautl -decrypt \
            -inkey ./team-private-key.pem \
            -in "$ENCRYPTED_KEY" \
            -out ./temp-aes-key; then
            echo "‚ùå Failed to decrypt AES key"
            exit 1
          fi

          # Read AES key
          AES_KEY=$(cat ./temp-aes-key)

          # Decrypt data (try GCM first, then CBC)
          echo "üîì Decrypting environment data..."
          if openssl enc -aes-256-gcm -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-GCM"
          elif openssl enc -aes-256-cbc -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-CBC"
          else
            echo "‚ùå Decryption failed with both AES-GCM and AES-CBC"
            exit 1
          fi

          # Verify decrypted content (without exposing content)
          if [[ -f "./.env" ]]; then
            LINES=$(wc -l < "./.env")
            SIZE=$(stat -c%s "./.env")
            echo "‚úÖ Decryption completed successfully!"
            echo "üìã Decrypted .env file: $LINES lines, $SIZE bytes"
            echo "‚ö†Ô∏è Environment variables are available for build process only"
            
            # Ensure .env is not tracked by git
            echo ".env" >> .gitignore
            git add .gitignore 2>/dev/null || true
          else
            echo "‚ùå Decrypted .env file not found"
            exit 1
          fi

      - name: Extract NEXT_PUBLIC environment variables
        id: extract-env
        if: steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üîç Extracting NEXT_PUBLIC_* environment variables..."
          
          if [[ ! -f "./.env" ]]; then
            echo "‚ö†Ô∏è No .env file found - skipping environment variable extraction"
            echo "has_next_public_vars=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Extract NEXT_PUBLIC_* variables (without exposing values in logs)
          NEXT_PUBLIC_VARS=$(grep '^NEXT_PUBLIC_' ./.env 2>/dev/null || true)
          
          if [[ -z "$NEXT_PUBLIC_VARS" ]]; then
            echo "‚ÑπÔ∏è No NEXT_PUBLIC_* variables found in .env file"
            echo "has_next_public_vars=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Count variables found (without showing values)
          VAR_COUNT=$(echo "$NEXT_PUBLIC_VARS" | wc -l)
          echo "‚úÖ Found $VAR_COUNT NEXT_PUBLIC_* environment variables"
          echo "has_next_public_vars=true" >> $GITHUB_OUTPUT
          
          # Create build args string for Docker
          BUILD_ARGS=""
          echo "$NEXT_PUBLIC_VARS" | while IFS='=' read -r key value; do
            if [[ -n "$key" && -n "$value" ]]; then
              # Mask the value in logs for security
              echo "::add-mask::$value"
              echo "Found: $key=***MASKED***"
              
              # Append to build args (values will be masked in logs)
              if [[ -z "$BUILD_ARGS" ]]; then
                BUILD_ARGS="$key=$value"
              else
                BUILD_ARGS="$BUILD_ARGS"$'\n'"$key=$value"
              fi
            fi
          done
          
          # Save build args to output file (will be masked)
          echo "$NEXT_PUBLIC_VARS" > ./next-public-build-args.txt
          
          echo "üîí Environment variables prepared for Docker build (values masked in logs)"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Check for package.json
        run: |
          if [ ! -f "package.json" ]; then
            echo "‚ùå package.json not found"
            exit 1
          fi
          echo "‚úÖ package.json found"

      - name: Check for required Next.js files
        run: |
          # Check for essential Next.js files
          if [ ! -f "next.config.js" ] && [ ! -f "next.config.mjs" ] && [ ! -f "next.config.ts" ]; then
            echo "‚ö†Ô∏è No Next.js config file found, using defaults"
          else
            echo "‚úÖ Next.js configuration found"
          fi

          # Check for pages or app directory
          if [ ! -d "pages" ] && [ ! -d "app" ] && [ ! -d "src/pages" ] && [ ! -d "src/app" ]; then
            echo "‚ùå No pages or app directory found"
            exit 1
          fi
          echo "‚úÖ Next.js routing structure verified"

      - name: Validate package.json scripts
        run: |
          # Verify required scripts exist
          REQUIRED_SCRIPTS=("build" "start")
          for script in "${REQUIRED_SCRIPTS[@]}"; do
            if ! grep -q "\"$script\":" package.json; then
              echo "‚ùå Required script '$script' not found in package.json"
              exit 1
            fi
          done
          echo "‚úÖ Required npm scripts verified"

      - name: Build multi-platform Docker image
        run: |
          echo "üèóÔ∏è Building Docker image with environment variables..."
          
          # Prepare build command
          BUILD_CMD="docker buildx build --platform linux/amd64,linux/arm64"
          BUILD_CMD="$BUILD_CMD --cache-from type=gha --cache-to type=gha,mode=max"
          BUILD_CMD="$BUILD_CMD -t cloudinsight-frontend:latest -t cloudinsight-frontend:${{ github.sha }}"
          
          # Add NEXT_PUBLIC_* build args if available
          if [[ "${{ steps.extract-env.outputs.has_next_public_vars }}" == "true" && -f "./next-public-build-args.txt" ]]; then
            echo "üîí Adding NEXT_PUBLIC_* environment variables as build arguments..."
            
            while IFS='=' read -r key value; do
              if [[ -n "$key" && -n "$value" ]]; then
                BUILD_CMD="$BUILD_CMD --build-arg $key=$value"
                echo "Added build arg: $key=***MASKED***"
              fi
            done < ./next-public-build-args.txt
          else
            echo "‚ÑπÔ∏è No NEXT_PUBLIC_* variables found - building without environment build args"
          fi
          
          # Add context at the end
          BUILD_CMD="$BUILD_CMD ."
          
          # Execute build command
          echo "üöÄ Executing Docker build..."
          eval "$BUILD_CMD"
          
          echo "‚úÖ Docker image built successfully with environment variables"

      - name: Test Docker image
        run: |
          echo "üß™ Testing Docker image functionality..."

          # Load the built image (use the latest tag)
          docker buildx build --load --platform linux/amd64 -t cloudinsight-frontend:test .

          # Run the container in detached mode
          CONTAINER_ID=$(docker run -d -p 3000:3000 cloudinsight-frontend:test)

          # Wait for container to start
          sleep 10

          # Check if container is running
          if docker ps | grep $CONTAINER_ID; then
            echo "‚úÖ Container started successfully"
            
            # Optional: Test if the app responds (requires curl)
            if command -v curl &> /dev/null; then
              if curl -f http://localhost:3000 &> /dev/null; then
                echo "‚úÖ Application responds to HTTP requests"
              else
                echo "‚ö†Ô∏è Application not responding (this might be normal for some setups)"
              fi
            fi
          else
            echo "‚ùå Container failed to start"
            docker logs $CONTAINER_ID
            exit 1
          fi

          # Cleanup
          docker stop $CONTAINER_ID && docker rm $CONTAINER_ID

      - name: Check for environment example
        run: |
          if [ -f ".env.example" ] || [ -f ".env.local.example" ]; then
            echo "‚úÖ Environment example file found"
          else
            echo "‚ö†Ô∏è No .env.example file found (recommended for Next.js projects)"
          fi

      - name: Final validation
        run: |
          echo "üéâ All CI checks passed successfully!"
          echo "‚úÖ Project structure validated"
          echo "‚úÖ Multi-platform Docker image built"
          echo "‚úÖ Container functionality tested"
          echo "‚úÖ Ready for deployment on AMD64 and ARM64 architectures"
