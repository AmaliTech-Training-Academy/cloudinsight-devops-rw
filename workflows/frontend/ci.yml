---
name: Frontend CI with Docker Multi-Platform Build and Deployment

# Principle of least privilege for GITHUB_TOKEN
permissions:
  contents: write
  checks: write # needed for test reporter annotations
  actions: read
  id-token: write

concurrency:
  group: frontend-ci-${{ github.ref }}
  cancel-in-progress: true

on:
  # Trigger on all branches for push events (commits)
  push:
    branches: ["*"]

  # Trigger on pull requests to any branch
  pull_request:
    branches: ["*"]

  # Trigger on merge events (when PR is merged)
  merge_group:
jobs:
  frontend-ci:
    name: Frontend CI Pipeline with Docker Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 1: Install pnpm and Node (ensure pnpm exists before cache logic)
      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9.0.0
          run_install: false

      - name: Setup Node.js 22 & enable pnpm cache
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "pnpm"
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies (pnpm)
        run: |
          # If lockfile exists use frozen for reproducibility; else normal install
          if [ -f pnpm-lock.yaml ]; then
            pnpm install --frozen-lockfile --prefer-offline
          else
            echo "No pnpm-lock.yaml yet ‚Äì performing non-frozen install (cache still warms)."
            pnpm install --prefer-offline
          fi

      - name: Prepare public env vars for tests (NEXT_PUBLIC_*)
        run: |
          echo "Preparing NEXT_PUBLIC_* variables for test environment..."
          # Try to source from existing example/test env files without exposing secrets
          for candidate in .env.test .env.example .env; do
            if [ -f "$candidate" ]; then
              echo "Scanning $candidate for NEXT_PUBLIC_* entries"
              grep '^NEXT_PUBLIC_' "$candidate" | while IFS='=' read -r k v; do
                if [ -n "$k" ] && [ -n "$v" ]; then
                  echo "Setting $k from $candidate"
                  echo "$k=$v" >> $GITHUB_ENV
                fi
              done
              break
            fi
          done
          # Provide safe defaults if still unset (avoid Zod errors). These should be overridden if real values are decrypted later.
          : ${NEXT_PUBLIC_API_BASE_URL:=http://localhost}
          : ${NEXT_PUBLIC_NODE_ENV:=test}
          echo "NEXT_PUBLIC_API_BASE_URL=${NEXT_PUBLIC_API_BASE_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_NODE_ENV=${NEXT_PUBLIC_NODE_ENV}" >> $GITHUB_ENV
          echo "Done preparing public env vars."

      # Step 2: Fast quality gates BEFORE docker build
      - name: Lint
        run: |
          if grep -q '"lint"' package.json; then
            echo "Running lint...";
            pnpm run lint || (echo 'Lint failed' && exit 1)
          else
            echo "No lint script found ‚Äì skipping"
          fi

      - name: Type check
        run: |
          if [ -f tsconfig.json ]; then
            echo "Running TypeScript type check...";
            pnpm exec tsc --noEmit --pretty false
          else
            echo "No tsconfig.json ‚Äì skipping type check"
          fi

      - name: Unit tests (Vitest)
        run: |
          set -e
          if grep -q 'vitest' package.json; then
            if pnpm exec vitest --version >/dev/null 2>&1; then
              echo "Running Vitest with JUnit + coverage reporters...";
              # Generate junit.xml, lcov.info and html report
              pnpm exec vitest run --reporter=default --reporter=junit --outputFile=junit.xml --coverage --coverage.reporter=lcov --coverage.reporter=html --run
            else
              echo "Vitest not installed? Ensure dependency is present."; exit 1
            fi
          elif grep -q '"test"' package.json; then
            echo "Running generic test script...";
            pnpm test -- --run || pnpm test
          else
            echo "No test framework detected ‚Äì skipping tests"
          fi

      - name: Upload frontend test artifacts
        if: ${{ always() }}
        run: |
          set -e
          mkdir -p ci-artifacts/frontend
          [ -f junit.xml ] && cp junit.xml ci-artifacts/frontend/ || true
          [ -f coverage/lcov.info ] && cp coverage/lcov.info ci-artifacts/frontend/ || true
          if [ -d coverage ]; then tar -czf ci-artifacts/frontend/coverage-html.tar.gz coverage ; fi

      - name: Store frontend artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: frontend-test-and-coverage
          path: ci-artifacts/frontend
          if-no-files-found: ignore
          retention-days: 7

      - name: Annotate frontend test results
        if: ${{ always() && hashFiles('junit.xml') != '' }}
        uses: dorny/test-reporter@v1
        with:
          name: Frontend Tests
          path: junit.xml
          reporter: jest-junit
          fail-on-error: false

      - name: Frontend coverage summary
        if: ${{ always() }}
        run: |
          echo "## Frontend Test Summary" >> $GITHUB_STEP_SUMMARY
          if [ -f junit.xml ]; then
            TOTAL=$(grep -o 'tests="[0-9]\+"' junit.xml | head -1 | cut -d '"' -f2 || echo 0)
            FAIL=$(grep -o 'failures="[0-9]\+"' junit.xml | head -1 | cut -d '"' -f2 || echo 0)
            echo "Tests: $TOTAL, Failures: $FAIL" >> $GITHUB_STEP_SUMMARY
          else
            echo "No junit.xml produced" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -f coverage/lcov.info ]; then
            # Approximate line coverage: lines with hits / total lines instrumented
            COVERED_LINES=$(grep '^DA:' coverage/lcov.info | awk -F'[,:]' '$3>0{c++} END{print c+0}')
            TOTAL_LINES=$(grep '^DA:' coverage/lcov.info | wc -l | awk '{print $1+0}')
            if [ "$TOTAL_LINES" -gt 0 ]; then FRONTEND_COVERAGE_PERCENT=$(awk -v c=$COVERED_LINES -v t=$TOTAL_LINES 'BEGIN{printf("%.2f", (c/t)*100)}'); else FRONTEND_COVERAGE_PERCENT=0; fi
            echo "Coverage (line approx): ${FRONTEND_COVERAGE_PERCENT}% ($COVERED_LINES/$TOTAL_LINES)" >> $GITHUB_STEP_SUMMARY
            # Export for later steps
            echo "FRONTEND_COVERAGE_PERCENT=${FRONTEND_COVERAGE_PERCENT}" >> $GITHUB_ENV
          else
            echo "No coverage file" >> $GITHUB_STEP_SUMMARY
          fi

      # Decrypt only AFTER fast checks to reduce secret exposure window

      - name: Decrypt environment variables
        id: decrypt-env
        run: |
          echo "üîç Checking for encrypted environment files..."

          # Setup cleanup trap for any exit (success or failure) - but preserve .env for deployment
          cleanup() {
            echo "üßπ Performing security cleanup..."
            rm -f ./team-private-key.pem ./temp-aes-key ./next-public-build-args.txt
            echo "‚úÖ Security cleanup completed"
          }
          trap cleanup EXIT

          # Find encrypted files in repository root
          ENCRYPTED_DATA=$(find . -maxdepth 1 -name "encrypted-env-vars.enc" -type f | head -1)
          ENCRYPTED_KEY=$(find . -maxdepth 1 -name "encrypted-aes-key.enc" -type f | head -1)
          METADATA=$(find . -maxdepth 1 -name "encrypted-env-vars.meta" -type f | head -1)

          if [[ -z "$ENCRYPTED_DATA" || -z "$ENCRYPTED_KEY" ]]; then
            echo "‚ÑπÔ∏è No encrypted environment files found - continuing without decryption"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Found encrypted files:"
          echo "  Data: $ENCRYPTED_DATA"
          echo "  Key: $ENCRYPTED_KEY"
          if [[ -n "$METADATA" ]]; then
            echo "  Metadata: $METADATA"
          fi
          echo "has_encrypted_env=true" >> $GITHUB_OUTPUT

          # Create private key from secret
          echo "üîë Setting up private key for decryption..."
          echo "${{ secrets.TEAM_PRIVATE_KEY }}" > ./team-private-key.pem
          chmod 600 ./team-private-key.pem

          # Verify private key
          if ! openssl rsa -in ./team-private-key.pem -check -noout; then
            echo "‚ùå Invalid private key in TEAM_PRIVATE_KEY secret"
            exit 1
          fi
          echo "‚úÖ Private key validated"

          # Show metadata if available (without sensitive content)
          if [[ -n "$METADATA" && -f "$METADATA" ]]; then
            echo "üìã Encryption Metadata:"
            echo "======================="
            cat "$METADATA"
            echo "======================="
          fi

          # Decrypt AES key
          echo "üîì Decrypting AES key..."
          if ! openssl rsautl -decrypt \
            -inkey ./team-private-key.pem \
            -in "$ENCRYPTED_KEY" \
            -out ./temp-aes-key; then
            echo "‚ùå Failed to decrypt AES key"
            exit 1
          fi

          # Read AES key
          AES_KEY=$(cat ./temp-aes-key)

          # Decrypt data (try GCM first, then CBC)
          echo "üîì Decrypting environment data..."
          if openssl enc -aes-256-gcm -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-GCM"
          elif openssl enc -aes-256-cbc -d \
            -in "$ENCRYPTED_DATA" \
            -out "./.env" \
            -pass "pass:$AES_KEY" 2>/dev/null; then
            echo "‚úÖ Decrypted with AES-CBC"
          else
            echo "‚ùå Decryption failed with both AES-GCM and AES-CBC"
            exit 1
          fi

          # Verify decrypted content (without exposing content)
          if [[ -f "./.env" ]]; then
            LINES=$(wc -l < "./.env")
            SIZE=$(stat -c%s "./.env")
            echo "‚úÖ Decryption completed successfully!"
            echo "üìã Decrypted .env file: $LINES lines, $SIZE bytes"
            echo "‚ö†Ô∏è Environment variables are available for build process only"
            
            # Ensure .env is not tracked by git
            # Add to .gitignore once (avoid duplicates across runs)
            grep -q '^\.env$' .gitignore 2>/dev/null || echo ".env" >> .gitignore
            git add .gitignore 2>/dev/null || true
          else
            echo "‚ùå Decrypted .env file not found"
            exit 1
          fi

      - name: Extract NEXT_PUBLIC environment variables
        id: extract-env
        if: steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üîç Extracting NEXT_PUBLIC_* environment variables..."

          if [[ ! -f "./.env" ]]; then
            echo "‚ö†Ô∏è No .env file found - skipping environment variable extraction"
            echo "has_next_public_vars=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract NEXT_PUBLIC_* variables (without exposing values in logs)
          NEXT_PUBLIC_VARS=$(grep '^NEXT_PUBLIC_' ./.env 2>/dev/null || true)

          if [[ -z "$NEXT_PUBLIC_VARS" ]]; then
            echo "‚ÑπÔ∏è No NEXT_PUBLIC_* variables found in .env file"
            echo "has_next_public_vars=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Count variables found (without showing values)
          VAR_COUNT=$(echo "$NEXT_PUBLIC_VARS" | wc -l)
          echo "‚úÖ Found $VAR_COUNT NEXT_PUBLIC_* environment variables"
          echo "has_next_public_vars=true" >> $GITHUB_OUTPUT

          # Create build args string for Docker
          BUILD_ARGS=""
          echo "$NEXT_PUBLIC_VARS" | while IFS='=' read -r key value; do
            if [[ -n "$key" && -n "$value" ]]; then
              # Mask the value in logs for security
              echo "::add-mask::$value"
              echo "Found: $key=***MASKED***"
              
              # Append to build args (values will be masked in logs)
              if [[ -z "$BUILD_ARGS" ]]; then
                BUILD_ARGS="$key=$value"
              else
                BUILD_ARGS="$BUILD_ARGS"$'\n'"$key=$value"
              fi
            fi
          done

          # Save build args to output file (will be masked)
          echo "$NEXT_PUBLIC_VARS" > ./next-public-build-args.txt

          echo "üîí Environment variables prepared for Docker build (values masked in logs)"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy environment variables to AWS Secrets Manager
        if: steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üöÄ Deploying environment variables to AWS Secrets Manager..."

          # Verify .env file exists
          if [[ ! -f ./.env ]]; then
            echo "‚ùå .env file not found! This should not happen if decryption succeeded."
            exit 1
          fi

          SECRET_NAME="${{ secrets.AWS_SECRET_NAME_FRONTEND }}"
          if [[ -z "$SECRET_NAME" ]]; then
            echo "‚ùå AWS_SECRET_NAME_FRONTEND secret not configured"
            exit 1
          fi

          # Remove database secrets from .env before processing (for consistency)
          echo "üö´ Removing database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) from environment variables..."
          sed -i '/^DB_PASSWORD=/d; /^DB_URL=/d; /^DB_USERNAME=/d' .env

          echo "üìä Remaining environment variables after database secret exclusion:"
          grep -c "^[^#].*=" .env || echo "0"

          # Check if secret exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Secret exists, updating with merge strategy..."
            
            # Get existing secret
            EXISTING_SECRET=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text)
            
            # Create temporary files for merging
            echo "$EXISTING_SECRET" > /tmp/existing.json
            
            # Create JSON from .env file
            echo "{" > /tmp/new_vars.json
            while IFS='=' read -r key value || [ -n "$key" ]; do
              # Skip empty lines and comment lines
              if [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]]; then
                continue
              fi
              
              # Remove inline comments from value (everything after # including the #)
              value=$(echo "$value" | sed 's/[[:space:]]*#.*$//')
              
              if [[ -n "$key" && -n "$value" ]]; then
                # Escape quotes in value and add to JSON
                escaped_value=$(echo "$value" | sed 's/"/\\"/g')
                echo "  \"$key\": \"$escaped_value\"," >> /tmp/new_vars.json
              fi
            done < .env
            # Remove trailing comma and close JSON
            sed -i '$ s/,$//' /tmp/new_vars.json
            echo "}" >> /tmp/new_vars.json
            
            # Merge with existing secret using jq
            jq -s '.[0] * .[1]' /tmp/existing.json /tmp/new_vars.json > /tmp/merged.json
            
            # Update secret with merged values
            aws secretsmanager update-secret \
              --secret-id "$SECRET_NAME" \
              --secret-string file:///tmp/merged.json
            
            echo "‚úÖ Secret updated successfully with merge strategy"
          else
            echo "üÜï Creating new secret..."
            
            # Convert .env to JSON
            echo "{" > /tmp/new.json
            while IFS='=' read -r key value || [ -n "$key" ]; do
              # Skip empty lines and comment lines
              if [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]]; then
                continue
              fi
              
              # Remove inline comments from value (everything after # including the #)
              value=$(echo "$value" | sed 's/[[:space:]]*#.*$//')
              
              if [[ -n "$key" && -n "$value" ]]; then
                # Escape quotes in value and add to JSON
                escaped_value=$(echo "$value" | sed 's/"/\\"/g')
                echo "  \"$key\": \"$escaped_value\"," >> /tmp/new.json
              fi
            done < .env
            # Remove trailing comma and close JSON
            sed -i '$ s/,$//' /tmp/new.json
            echo "}" >> /tmp/new.json
            
            # Create new secret
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --description "Frontend environment variables for ${{ github.repository }}" \
              --secret-string file:///tmp/new.json
            
            echo "‚úÖ Secret created successfully"
          fi

          # Cleanup
          rm -f /tmp/existing.json /tmp/merged.json /tmp/new.json /tmp/new_vars.json

          echo "üîê Environment variables deployed to AWS Secrets Manager: $SECRET_NAME"
          echo "üö´ Database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) excluded from deployment"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Calculate next semantic version
        id: semver
        run: |
          echo "üè∑Ô∏è Calculating next semantic version for branch: ${{ github.ref_name }}"
          BRANCH_NAME="${{ github.ref_name }}"

          # Get the latest tag from the current branch with branch suffix
          LATEST_TAG=$(git tag -l --sort=-version:refname "v*-${BRANCH_NAME}" | head -1 || echo "")

          if [[ -z "$LATEST_TAG" ]]; then
            # If no branch-specific tag, look for any v* tag for this branch's starting point
            LATEST_TAG=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
            # Remove any branch suffix if it exists
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          else
            # Remove the branch suffix to get the version number
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          fi

          echo "Latest tag found: $LATEST_TAG"

          # Extract version numbers
          if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            echo "Found existing version: v${MAJOR}.${MINOR}.${PATCH}"
            # Increment patch version
            PATCH=$((PATCH + 1))
          else
            echo "No semantic version tag found, starting with v0.1.0"
            MAJOR=0
            MINOR=1
            PATCH=0
          fi

          NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"

          echo "Next version: $NEXT_VERSION"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "version_no_v=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Check for package.json
        run: |
          if [ ! -f "package.json" ]; then
            echo "‚ùå package.json not found"
            exit 1
          fi
          echo "‚úÖ package.json found"

      - name: Check for required Next.js files
        run: |
          # Check for essential Next.js files
          if [ ! -f "next.config.js" ] && [ ! -f "next.config.mjs" ] && [ ! -f "next.config.ts" ]; then
            echo "‚ö†Ô∏è No Next.js config file found, using defaults"
          else
            echo "‚úÖ Next.js configuration found"
          fi

          # Check for pages or app directory
          if [ ! -d "pages" ] && [ ! -d "app" ] && [ ! -d "src/pages" ] && [ ! -d "src/app" ]; then
            echo "‚ùå No pages or app directory found"
            exit 1
          fi
          echo "‚úÖ Next.js routing structure verified"

      - name: Validate package.json scripts
        run: |
          # Verify required scripts exist
          REQUIRED_SCRIPTS=("build" "start")
          for script in "${REQUIRED_SCRIPTS[@]}"; do
            if ! grep -q "\"$script\":" package.json; then
              echo "‚ùå Required script '$script' not found in package.json"
              exit 1
            fi
          done
          echo "‚úÖ Required npm scripts verified"

      # Step 3: Build and push Docker image to ECR only after fast checks succeed
      - name: Build and push multi-platform Docker image to ECR
        run: |
          echo "üèóÔ∏è Building and pushing Docker image with environment variables (post-tests)..."

          BUILD_CMD="docker buildx build --platform linux/amd64,linux/arm64"
          BUILD_CMD="$BUILD_CMD --cache-from type=gha --cache-to type=gha,mode=max"
          BUILD_CMD="$BUILD_CMD --push"
          BUILD_CMD="$BUILD_CMD -t ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_FRONTEND }}:${{ steps.semver.outputs.version }}"
          BUILD_CMD="$BUILD_CMD -t ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_FRONTEND }}:latest"

          if [[ "${{ steps.extract-env.outputs.has_next_public_vars }}" == "true" && -f "./next-public-build-args.txt" ]]; then
            echo "üîí Adding NEXT_PUBLIC_* environment variables as build arguments..."
            while IFS='=' read -r key value; do
              if [[ -n "$key" && -n "$value" ]]; then
                BUILD_CMD="$BUILD_CMD --build-arg $key=$value"
                echo "Added build arg: $key=***MASKED***"
              fi
            done < ./next-public-build-args.txt
          else
            echo "‚ÑπÔ∏è No NEXT_PUBLIC_* variables found - building without environment build args"
          fi

          BUILD_CMD="$BUILD_CMD ."
          echo "üöÄ Executing Docker build and push to ECR..."
          eval "$BUILD_CMD"
          echo "‚úÖ Docker image built and pushed successfully to ECR with environment variables"

      - name: Create and push git tag
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/production')
        run: |
          # Extract branch name for tag prefix
          BRANCH_NAME="${{ github.ref_name }}"
          echo "üè∑Ô∏è Creating and pushing git tag for branch: $BRANCH_NAME"
          echo "üìù Version: ${{ steps.semver.outputs.version }}"

          # Configure git with GitHub token
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create branch-specific tag
          TAG_NAME="${{ steps.semver.outputs.version }}-${BRANCH_NAME}"

          # Check if tag already exists
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "‚ö†Ô∏è Tag $TAG_NAME already exists, skipping"
            exit 0
          fi

          # Create annotated tag with branch info
          git tag -a "$TAG_NAME" -m "Frontend release ${{ steps.semver.outputs.version }} from branch $BRANCH_NAME"

          # Push tag with authentication
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "$TAG_NAME"

          echo "‚úÖ Tag $TAG_NAME created and pushed successfully"

      - name: Check for environment example
        run: |
          if [ -f ".env.example" ] || [ -f ".env.local.example" ]; then
            echo "‚úÖ Environment example file found"
          else
            echo "‚ö†Ô∏è No .env.example file found (recommended for Next.js projects)"
          fi

      - name: Final validation
        run: |
          echo "üéâ All CI checks passed successfully!"
          echo "‚úÖ Project structure validated"
          echo "‚úÖ Multi-platform Docker image built and pushed to ECR"
          if [[ "${{ steps.decrypt-env.outputs.has_encrypted_env }}" == "true" ]]; then
            echo "‚úÖ Environment variables deployed to AWS Secrets Manager"
          fi
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/development" || "${{ github.ref }}" == "refs/heads/staging" || "${{ github.ref }}" == "refs/heads/production") ]]; then
            echo "‚úÖ Git tag ${{ steps.semver.outputs.version }}-${{ github.ref_name }} created and pushed"
          fi
          # Attempt to compute coverage percent again if env var not set
          if [ -z "$FRONTEND_COVERAGE_PERCENT" ] && [ -f coverage/lcov.info ]; then
            COVERED_LINES=$(grep '^DA:' coverage/lcov.info | awk -F'[,:]' '$3>0{c++} END{print c+0}')
            TOTAL_LINES=$(grep '^DA:' coverage/lcov.info | wc -l | awk '{print $1+0}')
            if [ "$TOTAL_LINES" -gt 0 ]; then FRONTEND_COVERAGE_PERCENT=$(awk -v c=$COVERED_LINES -v t=$TOTAL_LINES 'BEGIN{printf("%.2f", (c/t)*100)}'); else FRONTEND_COVERAGE_PERCENT=0; fi
          fi
          if [ -n "$FRONTEND_COVERAGE_PERCENT" ]; then
            echo "üìä Line coverage: ${FRONTEND_COVERAGE_PERCENT}%"; else echo "üìä Line coverage: n/a"; fi
          echo "üöÄ Frontend successfully deployed and ready for use"

      - name: Cleanup sensitive files
        if: always() && steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üßπ Cleaning up sensitive files..."
          rm -f ./.env ./team-private-key.pem ./temp-aes-key ./next-public-build-args.txt
          echo "‚úÖ Cleanup completed"
