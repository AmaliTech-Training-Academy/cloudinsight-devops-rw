name: Secrets Management

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: 'Target environment (development/staging/production)'
    outputs:
      secrets_deployed:
        description: 'Whether secrets were successfully deployed'
        value: ${{ jobs.secrets-push.outputs.deployed }}
        
jobs:
  secrets-push:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      deployed: ${{ steps.deploy-secrets.outputs.deployed }}
    steps:
      - uses: actions/checkout@v4
        
      - name: Setup Decryption Tools
        run: |
          echo "üîß Setting up decryption tools..."
          
          # Install SOPS
          echo "Installing SOPS..."
          curl -LO https://github.com/mozilla/sops/releases/latest/download/sops-v3.8.1.linux.amd64
          sudo mv sops-v3.8.1.linux.amd64 /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops
          
          # Install age (for SOPS)
          echo "Installing age..."
          curl -LO https://github.com/FiloSottile/age/releases/latest/download/age-v1.1.1-linux-amd64.tar.gz
          tar xzf age-v1.1.1-linux-amd64.tar.gz
          sudo mv age/age /usr/local/bin/
          sudo mv age/age-keygen /usr/local/bin/
          
          # Install ansible-vault (if not present)
          if ! command -v ansible-vault &> /dev/null; then
            echo "Installing ansible-vault..."
            pip install ansible-core
          fi
          
          echo "‚úÖ Decryption tools installed"
          
      - name: Auto-detect and Decrypt Secrets
        id: decrypt-secrets
        run: |
          echo "üîç Auto-detecting encrypted secrets files..."
          
          # Initialize
          DECRYPTION_SUCCESS=false
          DECRYPTED_FILE="/tmp/decrypted_secrets.json"
          
          # Look for existing workflow patterns first
          if find .github/workflows -name "*.yml" -exec grep -l "sops\|SOPS" {} \; 2>/dev/null | head -1; then
            echo "üìÅ Found SOPS usage in existing workflows"
            
            # Set up SOPS environment
            if [ -n "${{ secrets.SOPS_AGE_KEY }}" ]; then
              export SOPS_AGE_KEY="${{ secrets.SOPS_AGE_KEY }}"
              echo "üîë SOPS_AGE_KEY configured"
              
              # Find SOPS encrypted files
              for pattern in "*.sops.*" "*sops*" "secrets.sops.*" ".sops.*"; do
                for file in $(find . -name "$pattern" -type f 2>/dev/null); do
                  echo "üîç Trying to decrypt SOPS file: $file"
                  if sops -d "$file" > "$DECRYPTED_FILE" 2>/dev/null; then
                    echo "‚úÖ Successfully decrypted $file with SOPS"
                    DECRYPTION_SUCCESS=true
                    break 2
                  fi
                done
              done
            else
              echo "‚ö†Ô∏è SOPS_AGE_KEY secret not found"
            fi
            
          elif find .github/workflows -name "*.yml" -exec grep -l "gpg\|GPG" {} \; 2>/dev/null | head -1; then
            echo "üìÅ Found GPG usage in existing workflows"
            
            if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
              echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --import --batch 2>/dev/null
              echo "üîë GPG private key imported"
              
              # Find GPG encrypted files
              for pattern in "*.gpg" "*.asc" "secrets.gpg" "config.gpg"; do
                for file in $(find . -name "$pattern" -type f 2>/dev/null); do
                  echo "üîç Trying to decrypt GPG file: $file"
                  if gpg --decrypt --batch --yes "$file" > "$DECRYPTED_FILE" 2>/dev/null; then
                    echo "‚úÖ Successfully decrypted $file with GPG"
                    DECRYPTION_SUCCESS=true
                    break 2
                  fi
                done
              done
            else
              echo "‚ö†Ô∏è GPG_PRIVATE_KEY secret not found"
            fi
            
          elif find .github/workflows -name "*.yml" -exec grep -l "ansible-vault" {} \; 2>/dev/null | head -1; then
            echo "üìÅ Found Ansible Vault usage in existing workflows"
            
            if [ -n "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" ]; then
              echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > /tmp/vault_pass
              echo "üîë Ansible Vault password configured"
              
              # Find Ansible Vault encrypted files
              for pattern in "*.vault" "*vault*" "secrets.vault" "vars.vault"; do
                for file in $(find . -name "$pattern" -type f 2>/dev/null); do
                  echo "üîç Trying to decrypt Ansible Vault file: $file"
                  if ansible-vault decrypt --vault-password-file=/tmp/vault_pass "$file" --output="$DECRYPTED_FILE" 2>/dev/null; then
                    echo "‚úÖ Successfully decrypted $file with Ansible Vault"
                    DECRYPTION_SUCCESS=true
                    break 2
                  fi
                done
              done
            else
              echo "‚ö†Ô∏è ANSIBLE_VAULT_PASSWORD secret not found"
            fi
            
          else
            echo "üîç No recognized encryption method in workflows, trying generic patterns..."
            
            # Try common encrypted file patterns
            for file in secrets.enc secrets.encrypted config.enc app.enc; do
              if [ -f "$file" ]; then
                echo "üìÑ Found generic encrypted file: $file"
                
                # Try different decryption methods
                if [ -n "${{ secrets.ENCRYPTION_KEY }}" ]; then
                  echo "üîê Trying generic decryption..."
                  # Try openssl decryption
                  if openssl enc -aes-256-cbc -d -in "$file" -out "$DECRYPTED_FILE" -pass "pass:${{ secrets.ENCRYPTION_KEY }}" 2>/dev/null; then
                    echo "‚úÖ Successfully decrypted $file with OpenSSL"
                    DECRYPTION_SUCCESS=true
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Check if we found any secrets
          if [ "$DECRYPTION_SUCCESS" = true ] && [ -f "$DECRYPTED_FILE" ]; then
            # Validate JSON
            if jq . "$DECRYPTED_FILE" >/dev/null 2>&1; then
              echo "‚úÖ Decrypted secrets file is valid JSON"
              echo "decryption_success=true" >> $GITHUB_OUTPUT
              
              # Show summary (without values)
              SECRET_COUNT=$(jq 'keys | length' "$DECRYPTED_FILE")
              echo "üìä Found $SECRET_COUNT secret keys"
              
              # List secret keys (not values)
              echo "üîë Secret keys found:"
              jq -r 'keys[]' "$DECRYPTED_FILE" | while read key; do
                echo "  - $key"
              done
              
            else
              echo "‚ùå Decrypted file is not valid JSON"
              echo "File content preview:"
              head -5 "$DECRYPTED_FILE" 2>/dev/null || echo "Cannot read file"
              echo "decryption_success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è No encrypted secrets found or decryption failed"
            echo "Creating empty secrets file for demonstration"
            echo '{}' > "$DECRYPTED_FILE"
            echo "decryption_success=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy Secrets to AWS Secrets Manager
        id: deploy-secrets
        run: |
          echo "üöÄ Deploying secrets to AWS Secrets Manager..."
          
          # Get environment-specific secret name
          if [ -n "${{ secrets.AWS_SECRETS_MANAGER_SECRET_NAME }}" ]; then
            BASE_SECRET_NAME="${{ secrets.AWS_SECRETS_MANAGER_SECRET_NAME }}"
          else
            BASE_SECRET_NAME="cloudinsight"
          fi
          
          SECRET_NAME="${BASE_SECRET_NAME}-${{ inputs.environment }}"
          DECRYPTED_FILE="/tmp/decrypted_secrets.json"
          
          echo "üìù Target secret name: $SECRET_NAME"
          
          # Read the decrypted secrets
          if [ -f "$DECRYPTED_FILE" ]; then
            NEW_SECRETS=$(cat "$DECRYPTED_FILE")
            echo "üìÑ Loaded secrets from decrypted file"
          else
            echo "‚ö†Ô∏è No decrypted secrets file found, using empty JSON"
            NEW_SECRETS='{}'
          fi
          
          # Validate JSON
          if ! echo "$NEW_SECRETS" | jq . >/dev/null 2>&1; then
            echo "‚ùå New secrets are not valid JSON"
            echo "deployed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check if secret already exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "üìã Secret exists, merging with existing values..."
            
            # Get existing secrets
            EXISTING_SECRETS=$(aws secretsmanager get-secret-value \
              --secret-id "$SECRET_NAME" \
              --query 'SecretString' \
              --output text 2>/dev/null || echo '{}')
            
            # Validate existing secrets
            if ! echo "$EXISTING_SECRETS" | jq . >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Existing secrets are not valid JSON, treating as empty"
              EXISTING_SECRETS='{}'
            fi
            
            # Merge secrets (new values override existing ones)
            MERGED_SECRETS=$(echo "$EXISTING_SECRETS" "$NEW_SECRETS" | jq -s '.[0] * .[1]')
            
            echo "üîÑ Updating secret with merged values..."
            aws secretsmanager update-secret \
              --secret-id "$SECRET_NAME" \
              --secret-string "$MERGED_SECRETS"
              
          else
            echo "üìù Secret does not exist, creating new secret..."
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --secret-string "$NEW_SECRETS" \
              --description "CloudInsight secrets for ${{ inputs.environment }} environment"
          fi
          
          echo "‚úÖ Secrets deployed successfully to $SECRET_NAME"
          echo "deployed=true" >> $GITHUB_OUTPUT
          
          # Clean up sensitive files
          rm -f /tmp/decrypted_secrets.json /tmp/vault_pass
          
      - name: Deployment Summary
        run: |
          echo "## üîê Secrets Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Decryption Success:** ${{ steps.decrypt-secrets.outputs.decryption_success }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Success:** ${{ steps.deploy-secrets.outputs.deployed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Supported Encryption Methods" >> $GITHUB_STEP_SUMMARY
          echo "- **SOPS** with age encryption (requires \`SOPS_AGE_KEY\`)" >> $GITHUB_STEP_SUMMARY
          echo "- **GPG** encryption (requires \`GPG_PRIVATE_KEY\`)" >> $GITHUB_STEP_SUMMARY
          echo "- **Ansible Vault** (requires \`ANSIBLE_VAULT_PASSWORD\`)" >> $GITHUB_STEP_SUMMARY
          echo "- **Generic OpenSSL** (requires \`ENCRYPTION_KEY\`)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.deploy-secrets.outputs.deployed }}" = "true" ]; then
            echo "‚úÖ Secrets successfully deployed to AWS Secrets Manager"
          else
            echo "‚ùå Secrets deployment failed or no secrets found"
          fi